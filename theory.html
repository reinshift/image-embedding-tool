<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原理介绍 - 图像嵌入工具</title>
    
    <!-- 优化的资源加载 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css">

    <!-- 内联关键CSS -->
    <style>
        /* 加载优化 */
        .katex-display:empty, .inline-math:empty {
            background: linear-gradient(90deg, #f0f0f0 25%, transparent 25%);
            background-size: 20px 20px;
            animation: loading-shimmer 1.5s infinite;
            border-radius: 4px;
        }
        .katex-display:empty { min-height: 2.5em; margin: 1rem 0; }
        .inline-math:empty { min-width: 2em; min-height: 1.2em; display: inline-block; }

        @keyframes loading-shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }

        /* 简化的加载指示器 */
        .loading-indicator {
            position: fixed; top: 20px; right: 20px; z-index: 9999;
            background: rgba(36, 211, 122, 0.9); color: white;
            padding: 10px 20px; border-radius: 6px;
            font-size: 14px; font-weight: 500;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: none; transition: all 0.3s ease;
        }
        .loading-indicator.show { display: block; }

        /* 优化的布局 */
        .theory-container {
            min-height: 100vh;
            background: #f8f9fa;
            font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .theory-content { padding: 2rem 0; }
        .container { max-width: 900px; margin: 0 auto; padding: 0 1rem; }

        .theory-section {
            background: white;
            margin: 2rem 0;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }

        .section-title {
            color: #333;
            border-bottom: 2px solid #24d37a;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .math-block {
            background: #f8f9fa;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 6px;
            border-left: 3px solid #24d37a;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        .inline-math {
            background: rgba(36, 211, 122, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        /* 导航 */
        .theory-nav {
            background: white;
            color: #333;
            padding: 1rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 1px solid #e9ecef;
        }
        .nav-content {
            max-width: 900px; margin: 0 auto; padding: 0 1rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .nav-brand {
            display: flex; align-items: center; gap: 0.5rem;
        }
        .nav-title {
            font-size: 1.25rem; font-weight: 600;
            color: #333;
        }
        .back-btn {
            background: #24d37a;
            border: 1px solid #24d37a;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .back-btn:hover {
            background: #1cb967;
            border-color: #1cb967;
            transform: translateY(-1px);
        }

        /* 特殊样式 - 使用统一的绿色系配色方案 */
        .highlight-box {
            background: #1fab89;
            color: white;
            padding: 1.5rem;
            border-radius: 6px;
            margin: 1rem 0;
            border-left: 4px solid #0f7b6c;
        }
        .problem-box {
            background: #d7fbe8;
            border: 1px solid #9df3c4;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            color: #0f7b6c;
            border-left: 4px solid #62d2a2;
        }
        .solution-box {
            background: #9df3c4;
            border: 1px solid #62d2a2;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            color: #0f7b6c;
            border-left: 4px solid #1fab89;
        }
        .application-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .application-item {
            background: #d7fbe8;
            padding: 1rem;
            border-radius: 6px;
            border-left: 3px solid #1fab89;
            border: 1px solid #9df3c4;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            color: #0f7b6c;
        }

        /* 文字样式 */
        h3 {
            color: #333;
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        h4 {
            color: #333;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        ul, ol {
            color: #555;
            padding-left: 1.5rem;
        }

        li {
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body>
    <!-- 简化的加载指示器 -->
    <div id="loading-indicator" class="loading-indicator">
        正在渲染数学公式... <span id="progress-text">0/0</span>
    </div>

    <div class="theory-container">
        <!-- 导航栏 -->
        <nav class="theory-nav">
            <div class="nav-content">
                <div class="nav-brand">
                    <span class="nav-title">📐 图像嵌入的数学原理</span>
                </div>
                <button class="back-btn" onclick="goBackToApp()">
                    ← 返回应用
                </button>
            </div>
        </nav>

        <!-- 主内容 -->
        <div class="theory-content">
            <div class="container">
                <!-- 1. 图像嵌入背景介绍 -->
                <section class="theory-section">
                    <h2 class="section-title">1. 图像嵌入的背景与应用</h2>

                    <h3>1.1 什么是图像嵌入？</h3>
                    <p>图像嵌入是指将一张图像（源图像）变形后放置到另一张图像（目标图像）的指定区域内的技术。这种技术在现代计算机视觉和图像处理中有着广泛的应用。</p>

                    <div class="highlight-box">
                        <h4>🎯 核心问题</h4>
                        <p>如何将一个矩形的源图像精确地嵌入到目标图像中的任意四边形区域？</p>
                    </div>

                    <h3>1.2 数学问题描述</h3>
                    <p>假设我们有：</p>
                    <ul>
                        <li>源图像：尺寸为 <span class="inline-math" id="source-size"></span> 的矩形图像</li>
                        <li>目标区域：由四个顶点 <span class="inline-math" id="target-vertices"></span> 定义的四边形</li>
                    </ul>

                    <p>源图像的四个角点坐标为：</p>
                    <div class="math-block">
                        <div class="katex-display" id="source-corners"></div>
                    </div>

                    <p>我们需要找到一个数学变换，将这些角点精确映射到目标四边形的顶点：</p>
                    <div class="math-block">
                        <div class="katex-display" id="mapping-requirement"></div>
                    </div>
                </section>

                <!-- 2. 单应性变换介绍 -->
                <section class="theory-section">
                    <h2 class="section-title">2. 单应性变换：解决问题的数学工具</h2>

                    <h3>2.1 为什么需要单应性变换？</h3>
                    <p>要将矩形变换为任意四边形，我们需要一种能够处理透视变形的数学变换。单应性变换（Homography）正是这样的工具。</p>

                    <div class="problem-box">
                        <h4>⚠️ 为什么简单的仿射变换不够？</h4>
                        <p>仿射变换只能保持平行线平行，无法处理透视效果。而单应性变换可以将矩形变换为任意四边形，包括具有透视效果的梯形。</p>
                    </div>

                    <h3>2.2 单应性变换的数学定义</h3>
                    <p>单应性变换是一种射影变换，在齐次坐标系下可以表示为矩阵乘法：</p>
                    <div class="math-block">
                        <div class="katex-display" id="homography-definition"></div>
                    </div>

                    <p>其中 <span class="inline-math" id="H-matrix"></span> 是一个 3×3 的单应矩阵。</p>

                    <h3>2.3 从齐次坐标到笛卡尔坐标</h3>
                    <p>将齐次坐标转换回普通的二维坐标：</p>
                    <div class="math-block">
                        <div class="katex-display" id="coordinate-conversion"></div>
                    </div>

                    <p>这就是我们最终用于图像变换的公式。</p>
                </section>

                <!-- 3. 单应矩阵的结构 -->
                <section class="theory-section">
                    <h2 class="section-title">3. 单应矩阵的结构与性质</h2>

                    <h3>3.1 单应矩阵的一般形式</h3>
                    <p>单应矩阵 <span class="inline-math" id="H-general"></span> 的一般形式为：</p>
                    <div class="math-block">
                        <div class="katex-display" id="matrix-structure"></div>
                    </div>

                    <h3>3.2 自由度分析</h3>
                    <p>虽然矩阵有9个元素，但由于齐次性质（矩阵可以乘以任意非零常数），实际上只有8个独立参数。</p>

                    <div class="solution-box">
                        <h4>💡 关键洞察</h4>
                        <p>8个独立参数意味着我们需要至少4对对应点来确定单应矩阵（每对点提供2个约束方程）。</p>
                    </div>

                    <h3>3.3 约束方程的建立</h3>
                    <p>对于每对对应点 <span class="inline-math" id="point-pair"></span>，我们有约束：</p>
                    <div class="math-block">
                        <div class="katex-display" id="constraint-equation"></div>
                    </div>

                    <p>这等价于叉积为零：</p>
                    <div class="math-block">
                        <div class="katex-display" id="cross-product-zero"></div>
                    </div>
                </section>

                <!-- 4. 求解单应矩阵：核心算法 -->
                <section class="theory-section">
                    <h2 class="section-title">4. 求解单应矩阵：核心算法</h2>

                    <h3>4.1 线性方程组的构建</h3>
                    <p>将单应矩阵的9个元素排列成向量：</p>
                    <div class="math-block">
                        <div class="katex-display" id="matrix-vectorization"></div>
                    </div>

                    <p>每对对应点提供两个线性约束方程，4对点共8个方程：</p>
                    <div class="math-block">
                        <div class="katex-display" id="linear-system"></div>
                    </div>

                    <h3>4.2 理想情况：4对点的精确解</h3>
                    <p>如果我们恰好有4对对应点，且这些点处于一般位置（没有三点共线），那么我们得到一个8×9的矩阵方程。</p>

                    <div class="problem-box">
                        <h4>🤔 为什么不能直接求逆？</h4>
                        <p>因为我们有8个方程但9个未知数，这是一个欠定系统。而且由于齐次性质，我们实际上是在寻找矩阵 <span class="inline-math" id="A-matrix"></span> 的零空间。</p>
                    </div>

                    <h3>4.3 实际情况：超定系统</h3>
                    <p>在实际应用中，我们通常有超过4对点，这时系统变成超定的（方程数大于未知数）。我们需要寻找最小二乘解：</p>
                    <div class="math-block">
                        <div class="katex-display" id="least-squares"></div>
                    </div>
                </section>

                <!-- 5. 广义逆与SVD：数学工具 -->
                <section class="theory-section">
                    <h2 class="section-title">5. 广义逆与SVD：求解的数学工具</h2>

                    <h3>5.1 为什么需要广义逆？</h3>
                    <p>当矩阵不是方阵或者不可逆时，我们需要广义逆（伪逆）来求解线性方程组。</p>

                    <div class="solution-box">
                        <h4>💡 Moore-Penrose伪逆</h4>
                        <p>对于矩阵 <span class="inline-math" id="matrix-A"></span>，其伪逆 <span class="inline-math" id="pseudoinverse"></span> 定义为：</p>
                        <div class="math-block">
                            <div class="katex-display" id="pseudoinverse-definition"></div>
                        </div>
                    </div>

                    <h3>5.2 奇异值分解（SVD）</h3>
                    <p>SVD是计算伪逆的最稳定方法。对于任意矩阵 <span class="inline-math" id="matrix-A-svd"></span>：</p>
                    <div class="math-block">
                        <div class="katex-display" id="svd-decomposition"></div>
                    </div>

                    <p>其中：</p>
                    <ul>
                        <li><span class="inline-math" id="U-matrix"></span> 和 <span class="inline-math" id="V-matrix"></span> 是正交矩阵</li>
                        <li><span class="inline-math" id="sigma-matrix"></span> 是对角矩阵，包含奇异值</li>
                    </ul>

                    <h3>5.3 通过SVD求解</h3>
                    <p>单应矩阵对应于矩阵 <span class="inline-math" id="A-svd"></span> 最小奇异值对应的右奇异向量：</p>
                    <div class="math-block">
                        <div class="katex-display" id="svd-solution"></div>
                    </div>
                </section>

                <!-- 6. 本项目的图像嵌入Pipeline -->
                <section class="theory-section">
                    <h2 class="section-title">6. 本项目的图像嵌入Pipeline</h2>

                    <h3>6.1 完整的算法流程</h3>
                    <div class="highlight-box">
                        <h4>🔄 图像嵌入算法步骤</h4>
                        <ol>
                            <li><strong>输入处理</strong>：获取源图像和目标四边形顶点</li>
                            <li><strong>对应点设置</strong>：建立源图像角点与目标顶点的对应关系</li>
                            <li><strong>构建约束矩阵</strong>：根据对应点构建线性方程组</li>
                            <li><strong>SVD求解</strong>：计算单应矩阵</li>
                            <li><strong>图像变换</strong>：应用单应变换到源图像</li>
                            <li><strong>结果合成</strong>：将变换后的图像嵌入到目标图像</li>
                        </ol>
                    </div>

                    <h3>6.2 对应点的精确定义</h3>
                    <p>在我们的实现中，对应关系定义如下：</p>
                    <div class="math-block">
                        <div class="katex-display" id="project-correspondence"></div>
                    </div>

                    <h3>6.3 实际变换公式</h3>
                    <p>对于源图像中的每个像素点 <span class="inline-math" id="source-pixel"></span>，其在目标图像中的位置为：</p>
                    <div class="math-block">
                        <div class="katex-display" id="pixel-transform"></div>
                    </div>

                    <h3>6.4 实现中的技术细节</h3>
                    <ul>
                        <li><strong>逆向映射</strong>：为避免空洞，我们从目标像素反向计算源像素位置</li>
                        <li><strong>双线性插值</strong>：处理非整数坐标的像素值</li>
                        <li><strong>边界检查</strong>：确保变换后的像素在有效范围内</li>
                        <li><strong>透明度处理</strong>：支持带透明通道的图像嵌入</li>
                    </ul>
                </section>

                <!-- 7. 其他应用领域 -->
                <section class="theory-section">
                    <h2 class="section-title">7. 单应性变换的其他应用</h2>

                    <p>单应性变换作为计算机视觉的基础工具，在许多领域都有重要应用：</p>

                    <div class="application-grid">
                        <div class="application-item">
                            <h4>🚗 汽车环视系统</h4>
                            <p>将多个摄像头的图像拼接成鸟瞰图，帮助驾驶员了解车辆周围环境。</p>
                        </div>
                        <div class="application-item">
                            <h4>📱 增强现实(AR)</h4>
                            <p>将虚拟物体准确地叠加到现实场景中，实现虚实融合的视觉效果。</p>
                        </div>
                        <div class="application-item">
                            <h4>📷 图像拼接</h4>
                            <p>将多张有重叠区域的照片拼接成全景图像。</p>
                        </div>
                        <div class="application-item">
                            <h4>🏢 建筑测量</h4>
                            <p>从倾斜拍摄的建筑照片中恢复真实的几何尺寸。</p>
                        </div>
                        <div class="application-item">
                            <h4>🎮 游戏开发</h4>
                            <p>实现3D场景到2D屏幕的透视投影变换。</p>
                        </div>
                        <div class="application-item">
                            <h4>🔍 文档扫描</h4>
                            <p>校正倾斜拍摄的文档，恢复矩形的文档形状。</p>
                        </div>
                    </div>

                    <h3>7.1 技术发展趋势</h3>
                    <p>随着深度学习的发展，单应性变换的估计也在不断改进：</p>
                    <ul>
                        <li><strong>深度学习方法</strong>：使用神经网络直接预测单应矩阵</li>
                        <li><strong>实时处理</strong>：GPU加速使得实时单应变换成为可能</li>
                        <li><strong>鲁棒性提升</strong>：结合RANSAC等算法处理噪声和异常值</li>
                        <li><strong>多视图几何</strong>：扩展到多个视角的同时处理</li>
                    </ul>
                </section>

                <!-- 总结 -->
                <section class="theory-section">
                    <h2 class="section-title">总结</h2>

                    <div class="highlight-box">
                        <h4>🎯 核心要点回顾</h4>
                        <ul>
                            <li><strong>问题本质</strong>：将矩形图像变换为任意四边形</li>
                            <li><strong>数学工具</strong>：单应性变换提供了完美的解决方案</li>
                            <li><strong>求解方法</strong>：通过SVD求解超定线性方程组</li>
                            <li><strong>实际应用</strong>：从图像嵌入到AR，应用广泛</li>
                        </ul>
                    </div>

                    <p>通过理解单应性变换的数学原理，我们不仅能够实现精确的图像嵌入，还为进一步探索计算机视觉的其他领域奠定了坚实的理论基础。</p>

                    <p>这个看似简单的"将图像放到四边形中"的问题，实际上涉及了线性代数、数值分析、计算几何等多个数学分支，体现了数学在解决实际问题中的强大威力。</p>
                </section>
            </div>
        </div>
    </div>

    <!-- 优化的脚本加载 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js"></script>
    <script src="theory-final.js"></script>
</body>
</html>
